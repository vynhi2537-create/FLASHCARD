<script type="module">
    // --- C·∫§U H√åNH API V√Ä KH·ªûI T·∫†O ---
    const API_KEY = ""; // S·∫Ω ƒë∆∞·ª£c Canvas cung c·∫•p (n·∫øu b·∫°n d√πng API th·∫≠t)
    const TEXT_MODEL = "gemini-2.5-flash-preview-09-2025";
    const TTS_MODEL = "gemini-2.5-flash-preview-tts";
    const API_URL_TEXT = `https://generativelanguage.googleapis.com/v1beta/models/${TEXT_MODEL}:generateContent?key=${API_KEY}`;
    const API_URL_TTS = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${API_KEY}`;

    let currentCardIndex = 0;
    let isTestMode = false;

    // (cardData gi·ªØ nguy√™n t·ª´ file c≈©)
    let cardData = [ /* ... gi·ªØ nguy√™n m·∫£ng t·ª´ b·∫°n c√≥ ... */ ];

    let conversation = null;
    let challengeIndex = 0;

    document.addEventListener('DOMContentLoaded', () => {
        loadCardsFromLocalStorage();
        renderCard();
        // Kh·ªüi t·∫°o c√°c icon lucide sau khi DOM load (n·∫øu c√≥)
        if (window.lucide && lucide.createIcons) lucide.createIcons();
    });

    // --- (c√°c h√†m load/save, renderCard, updateNavigationButtons, flipCard, toggleTestMode, checkTestAnswer, showNext/Prev... )
    // gi·ªØ nguy√™n c√°c h√†m kh√°c trong file c≈©, kh√¥ng ƒë·ªïi tr·ª´ ph·∫ßn AI v√† checkChallenge
    // (ƒê·ªÉ ng·∫Øn g·ªçn ·ªü ƒë√¢y m√¨nh gi·∫£ ƒë·ªãnh b·∫°n v·∫´n gi·ªØ c√°c h√†m tr√™n gi·ªëng b·∫£n g·ªëc.)

    // --- H·ªñ TR·ª¢ PHOENIX: fetchWithRetry (kh√¥ng ƒë·ªïi) ---
    async function fetchWithRetry(url, options, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    // --- PH√ÅT √ÇM (gi·ªØ nguy√™n speakCurrentWord c·ªßa file c≈©) ---
    // (m·ª•c n√†y b·∫°n gi·ªØ nguy√™n code speakCurrentWord, playAudio, pcmToWav, base64ToArrayBuffer ... n·∫øu mu·ªën d√πng TTS API)
    // N·∫øu b·∫°n ch·ªâ mu·ªën fallback Web Speech API th√¨ ch·ªâ c·∫ßn ƒëo·∫°n g·ªçi speechSynthesis (b·∫£n c≈© c√≥ x·ª≠ l√Ω s·∫µn).

    // --- AI T·∫†O H·ªòI THO·∫†I & LUY·ªÜN T·∫¨P (S·ª¨A) ---
    const CONVERSATION_SCHEMA = {
        type: "OBJECT",
        properties: {
            title: { "type": "STRING", description: "Ti√™u ƒë·ªÅ ng·∫Øn cho ƒëo·∫°n h·ªôi tho·∫°i." },
            sentences: {
                type: "ARRAY",
                description: "M·ªói ph·∫ßn t·ª≠ l√† m·ªôt c√¢u trong h·ªôi tho·∫°i.",
                items: {
                    type: "OBJECT",
                    properties: {
                        speaker: { "type": "STRING", description: "T√™n ng∆∞·ªùi n√≥i (A ho·∫∑c B)." },
                        chinese: { "type": "STRING", description: "C√¢u n√≥i b·∫±ng H√°n t·ª±." },
                        pinyin: { "type": "STRING", description: "Pinyin c·ªßa c√¢u n√≥i." },
                        vietnamese: { "type": "STRING", description: "Nghƒ©a ti·∫øng Vi·ªát c·ªßa c√¢u n√≥i." }
                    }
                }
            }
        }
    };

    window.startConversationPractice = async function() {
        const card = cardData[currentCardIndex];
        const word = card.hanzi;
        const pinyin = card.pinyin;
        const meaning = card.meaning;

        // UI
        document.getElementById('conversation-area').classList.remove('hidden');
        const loadingConv = document.getElementById('loading-conv');
        loadingConv.classList.remove('hidden');
        document.getElementById('conversation-content').innerHTML = '';

        const systemPrompt = `B·∫°n l√† m·ªôt tr·ª£ gi·∫£ng ti·∫øng Trung. T·∫°o m·ªôt ƒëo·∫°n h·ªôi tho·∫°i ng·∫Øn (3-4 c√¢u) gi·ªØa hai ng∆∞·ªùi (A & B) d√πng t·ª´ "${word}" (Pinyin: ${pinyin}, Nghƒ©a: ${meaning}). Cho m·ªói c√¢u: H√°n t·ª±, Pinyin, Nghƒ©a ti·∫øng Vi·ªát. Tr·∫£ v·ªÅ JSON theo schema.`;

        const payload = {
            contents: [{ parts: [{ text: `T·∫°o h·ªôi tho·∫°i s·ª≠ d·ª•ng t·ª´ ${word}` }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: CONVERSATION_SCHEMA
            }
        };

        try {
            const result = await fetchWithRetry(API_URL_TEXT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const jsonString = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonString) throw new Error("API kh√¥ng tr·∫£ v·ªÅ JSON.");

            // parse JSON an to√†n
            let parsed = null;
            try {
                parsed = JSON.parse(jsonString);
            } catch (e) {
                // n·∫øu parse l·ªói, hi·ªÉn th·ªã message v√† d√πng fallback template
                console.error("JSON parse l·ªói t·ª´ API:", e);
                parsed = null;
            }

            // N·∫øu API kh√¥ng cung c·∫•p c·∫•u tr√∫c challenge_* th√¨ t·∫°o fallback
            if (parsed && Array.isArray(parsed.sentences) && parsed.sentences.length > 0) {
                // chu·∫©n h√≥a key names (m·ªôt s·ªë API c√≥ th·ªÉ tr·∫£ t√™n kh√°c)
                // ƒë·∫£m b·∫£o m·ªói sentence c√≥ {chinese, pinyin, vietnamese}
                parsed.sentences = parsed.sentences.map(s => ({
                    chinese: s.chinese || s.line_hanzi || s.line || "",
                    pinyin: s.pinyin || s.line_pinyin || "",
                    vietnamese: s.vietnamese || s.line_viet || s.vietnamese || ""
                }));

                // n·∫øu API kh√¥ng tr·∫£ challenge_* th√¨ build t·ª´ c√¢u ƒë·∫ßu
                if (!parsed.challenge_hanzi) {
                    parsed.challenge_hanzi = parsed.sentences[0].chinese;
                }
                if (!parsed.challenge_pinyin_answer) {
                    parsed.challenge_pinyin_answer = parsed.sentences[0].pinyin;
                }
                if (!parsed.challenge_viet_answer) {
                    parsed.challenge_viet_answer = parsed.sentences[0].vietnamese;
                }

                conversation = parsed;
            } else {
                // fallback local (n·∫øu API tr·∫£ v·ªÅ kh√¥ng h·ª£p l·ªá)
                conversation = {
                    title: `H·ªôi tho·∫°i v·ªõi ${word}`,
                    sentences: [
                        { speaker: "A", chinese: `${word} ‰Ω†Â•ΩÂêóÔºü`, pinyin: `${pinyin} n«ê h«éo ma?`, vietnamese: `${meaning} ‚Äî b·∫°n kh·ªèe kh√¥ng?` },
                        { speaker: "B", chinese: `ÊàëÂæàÂ•ΩÔºåË∞¢Ë∞¢„ÄÇ`, pinyin: `W«í hƒõn h«éo, xi√®xie.`, vietnamese: `M√¨nh kh·ªèe, c·∫£m ∆°n.` }
                    ],
                    challenge_hanzi: `${word} ‰Ω†Â•ΩÂêóÔºü`,
                    challenge_pinyin_answer: `${pinyin} n«ê h«éo ma?`,
                    challenge_viet_answer: `${meaning} ‚Äî b·∫°n kh·ªèe kh√¥ng?`
                };
            }

            renderConversation(conversation);
            setupChallenge(conversation);

        } catch (error) {
            console.error("L·ªói g·ªçi Gemini API (Conversation):", error);
            document.getElementById('conversation-content').innerHTML = `<p class="text-red-500">‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫°o h·ªôi tho·∫°i. Vui l√≤ng th·ª≠ l·∫°i.</p>`;
            // fallback local ƒë∆°n gi·∫£n
            conversation = {
                title: `H·ªôi tho·∫°i offline v·ªõi ${word}`,
                sentences: [
                    { speaker: "A", chinese: `${word} ‰Ω†Â•ΩÂêóÔºü`, pinyin: `${pinyin} n«ê h«éo ma?`, vietnamese: `${meaning} ‚Äî b·∫°n kh·ªèe kh√¥ng?` },
                    { speaker: "B", chinese: `ÊàëÂæàÂ•ΩÔºåË∞¢Ë∞¢„ÄÇ`, pinyin: `W«í hƒõn h«éo, xi√®xie.`, vietnamese: `M√¨nh kh·ªèe, c·∫£m ∆°n.` }
                ],
                challenge_hanzi: `${word} ‰Ω†Â•ΩÂêóÔºü`,
                challenge_pinyin_answer: `${pinyin} n«ê h«éo ma?`,
                challenge_viet_answer: `${meaning} ‚Äî b·∫°n kh·ªèe kh√¥ng?`
            };
            renderConversation(conversation);
            setupChallenge(conversation);
        } finally {
            loadingConv.classList.add('hidden');
        }
    }

    function renderConversation(conv) {
        const convContent = document.getElementById('conversation-content');
        let html = `<h3 class="text-xl font-bold text-gray-700 mb-3">${conv.title || ''}</h3>`;

        conv.sentences.forEach((sentence, index) => {
            const isA = (index % 2 === 0);
            const bubbleClass = isA ? 'bg-neon-teal text-white rounded-br-none' : 'bg-neon-pink text-white rounded-bl-none';
            html += `
                <div class="flex ${isA ? 'justify-start' : 'justify-end'} mb-2">
                    <div class="max-w-[80%] p-3 rounded-xl shadow-md ${bubbleClass}">
                        <div class="flex items-center justify-between mb-1">
                            <span class="font-bold text-sm">${sentence.speaker || (isA ? 'A' : 'B')}</span>
                            <button onclick="speakCurrentWord('${escapeForInline(sentence.chinese)}')" class="ml-2 hover:opacity-80">
                                <i data-lucide="volume-2" class="w-4 h-4"></i>
                            </button>
                        </div>
                        <p class="text-lg font-semibold">${sentence.chinese}</p>
                        <p class="text-sm italic opacity-80">${sentence.pinyin}</p>
                        <p class="text-xs mt-1 border-t border-white border-opacity-30 pt-1">${sentence.vietnamese}</p>
                    </div>
                </div>
            `;
        });
        convContent.innerHTML = html;
        if (window.lucide && lucide.createIcons) lucide.createIcons();
    }

    // helper: escape single quotes inside inline onclick so it doesn't break HTML
    function escapeForInline(s) {
        if (!s) return '';
        return s.replace(/'/g, "\\'");
    }

    function setupChallenge(conv) {
        challengeIndex = 0;
        // prefer explicit challenge fields, n·∫øu kh√¥ng c√≥ fallback sang c√¢u ƒë·∫ßu
        const challengeHanzi = conv.challenge_hanzi || conv.sentences?.[0]?.chinese || '';
        const challengePinyin = conv.challenge_pinyin_answer || conv.sentences?.[0]?.pinyin || '';
        const challengeViet = conv.challenge_viet_answer || conv.sentences?.[0]?.vietnamese || '';

        // g·∫Øn l·∫°i v√†o conversation ƒë·ªÉ checkChallenge d√πng
        conversation.challenge_hanzi = challengeHanzi;
        conversation.challenge_pinyin_answer = challengePinyin;
        conversation.challenge_viet_answer = challengeViet;

        document.getElementById('challenge-text').textContent = `D·ªãch c√¢u n√†y: ${challengeHanzi}`;
        document.getElementById('challenge-input').value = '';
        document.getElementById('challenge-input').placeholder = 'G√µ Pinyin ho·∫∑c Nghƒ©a Vi·ªát...';
        document.getElementById('challenge-feedback').textContent = '';
        document.getElementById('challenge-input').disabled = false;
    }

    // chu·∫©n h√≥a pinyin: b·ªè spaces, s·ªë tone (n·∫øu ng∆∞·ªùi nh·∫≠p d·∫°ng s·ªë), v√† d·∫•u
    function normalizePinyin(s) {
        if (!s) return '';
        return s.toLowerCase().replace(/\s+/g, '').replace(/[1-5]/g, '').replace(/[^\w\u0100-\uFFFF]/g, '');
    }

    // ch√≠nh: ki·ªÉm tra challenge (m·ªÅm h∆°n, ch·∫•p nh·∫≠n partial/keyword)
    window.checkChallenge = function() {
        if (!conversation) {
            document.getElementById('challenge-feedback').textContent = "Vui l√≤ng t·∫°o h·ªôi tho·∫°i tr∆∞·ªõc ƒë√£!";
            return;
        }

        const inputRaw = document.getElementById('challenge-input').value.trim().toLowerCase();
        const feedbackEl = document.getElementById('challenge-feedback');

        const expectedViet = (conversation.challenge_viet_answer || '').toLowerCase();
        const expectedPinyin = normalizePinyin(conversation.challenge_pinyin_answer || '');

        const inputNoSpace = inputRaw.replace(/\s+/g, '');
        const inputNormalizedPinyin = normalizePinyin(inputRaw);

        let isCorrect = false;

        // 1) Pinyin match (chu·∫©n h√≥a)
        if (inputNormalizedPinyin && expectedPinyin && inputNormalizedPinyin === expectedPinyin) {
            isCorrect = true;
        }

        // 2) Exact vietnamese match
        else if (inputRaw === expectedViet && inputRaw.length > 0) {
            isCorrect = true;
        }

        // 3) Partial keyword match: l·∫•y c√°c keyword t·ª´ expectedViet (b·ªè stopwords ng·∫Øn)
        else {
            const stopwords = new Set(['l√†','c·ªßa','v√†','c≈©ng','m·ªôt','c√°i','c√°c','nh·ªØng','·ªü','tr√™n','v·ªõi','ƒë√£','s·∫Ω','ƒëang']);
            const tokens = expectedViet.split(/\s+/).map(t => t.trim()).filter(t => t.length > 2 && !stopwords.has(t));
            if (tokens.length > 0 && tokens.some(tok => inputRaw.includes(tok))) {
                isCorrect = true;
            }
        }

        if (isCorrect) {
            feedbackEl.className = 'mt-2 font-semibold text-green-600';
            feedbackEl.textContent = `‚úÖ Ch√≠nh x√°c! (${conversation.challenge_viet_answer || ''} / ${conversation.challenge_pinyin_answer || ''})`;
            showReward(`Tuy·ªát v·ªùi! B·∫°n ƒë√£ d·ªãch ƒë√∫ng c√¢u s·ªë ${challengeIndex + 1}! üöÄ`);

            // next
            challengeIndex++;
            if (challengeIndex < (conversation.sentences?.length || 0)) {
                const next = conversation.sentences[challengeIndex];
                document.getElementById('challenge-text').textContent = `D·ªãch c√¢u ti·∫øp theo: ${next.chinese}`;
                document.getElementById('challenge-input').value = '';
            } else {
                feedbackEl.textContent = 'üéâ B·∫°n ƒë√£ ho√†n th√†nh to√†n b·ªô h·ªôi tho·∫°i! Chuy·ªÉn sang th·∫ª m·ªõi th√¥i!';
                document.getElementById('challenge-input').disabled = true;
            }
        } else {
            feedbackEl.className = 'mt-2 font-semibold text-red-600';
            feedbackEl.textContent = `‚ùå Ch∆∞a ch√≠nh x√°c. G·ª£i √Ω: vi·∫øt m·ªôt t·ª´ kh√≥a ch√≠nh ho·∫∑c g√µ Pinyin (b·ªè d·∫•u/kho·∫£ng tr·∫Øng).`;
        }
    }

    // --- TH√äM & L∆ØU T·ª™ M·ªöI (gi·ªØ nguy√™n) ---
    document.getElementById('add-card-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const newCard = {
            hanzi: document.getElementById('new-hanzi').value.trim(),
            pinyin: document.getElementById('new-pinyin').value.trim(),
            meaning: document.getElementById('new-meaning').value.trim(),
            tip: document.getElementById('new-tip').value.trim() || 'Ch∆∞a c√≥ c√°ch nh·ªõ.',
            reward: document.getElementById('new-reward').value.trim() || null
        };

        if (cardData.some(card => card.hanzi === newCard.hanzi)) {
            document.getElementById('save-status').textContent = "T·ª´ n√†y ƒë√£ c√≥ trong b·ªô th·∫ª r·ªìi!";
            setTimeout(()=> document.getElementById('save-status').textContent = '', 2500);
            return;
        }

        cardData.push(newCard);
        saveCardsToLocalStorage();
        document.getElementById('add-card-form').reset();
        currentCardIndex = cardData.length - 1;
        renderCard();
        document.getElementById('save-status').textContent = `ƒê√£ th√™m "${newCard.hanzi}"`;
        setTimeout(()=> document.getElementById('save-status').textContent = '', 2500);
    });

    // ----- C√°c h√†m ph·ª• (save, load, renderCard, showReward, hideReward, speakCurrentWord, playAudio, pcmToWav...) -----
    // ƒê·ªÉ ng·∫Øn g·ªçn, b·∫°n gi·ªØ l·∫°i c√°c h√†m n√†y t·ª´ file g·ªëc (m√¨nh kh√¥ng thay ƒë·ªïi ph·∫ßn ƒë√≥ tr·ª´ m·ª•c AI v√† checkChallenge).
    // N·∫øu b·∫°n mu·ªën, m√¨nh c√≥ th·ªÉ g·ª≠i l·∫°i to√†n b·ªô file index.html ƒë√£ ch·ªânh s·ª≠a (to√†n b·ªô script + HTML) ƒë·ªÉ thay th·∫ø nguy√™n file.

</script>
